#version 430 core
#define PI 3.1415926535897932384626433832795
#define G 9.81

layout (local_size_x = 16, local_size_y = 16) in;

layout (binding = 0, rgba32f) writeonly uniform image2D tilde_h0k;

layout (binding = 1, rgba32f) writeonly uniform image2D tilde_h0minusk;

layout (binding = 2) uniform sampler2D noise_r0;
layout (binding = 3) uniform sampler2D noise_i0;
layout (binding = 4) uniform sampler2D noise_r1;
layout (binding = 5) uniform sampler2D noise_i1;


uniform	int    FFT_dimension ;            //FFT resolution
uniform int    ocean_dimension;           //Ocean dimension
uniform float  amplitude ;           //apmtitude of what ???s
uniform float  windspeed ;
uniform vec2   wind_dir ;     // wind speed vector
uniform float  l;               // what is this l?
uniform float  alignment;

layout(std430, binding = 6) buffer gauss_real
{
    int r[];
}gauss_r;

layout(std430, binding = 7) buffer gauss_image
{
    int i[];
}gauss_i;

layout(std430, binding = 8) buffer h0data_r
{
    float r[];
}h0_r;

layout(std430, binding = 9) buffer h0data_i
{
    float i[];
}h0_i;

const float g = 9.81;

float k_w_power = 4.0;                // this can effect the strength of the wave

// Box-Muller-Method

vec4 gaussRND()
{	
	vec2 texCoord = vec2(gl_GlobalInvocationID.xy)/float(ocean_dimension);
	
	float noise00 = clamp(texture(noise_r0, texCoord).r +0.00001, 0.0, 1.0);
	float noise01 = clamp(texture(noise_i0, texCoord).r +0.00001, 0.0, 1.0);
	float noise02 = clamp(texture(noise_r1, texCoord).r +0.00001, 0.0, 1.0);
	float noise03 = clamp(texture(noise_i1, texCoord).r +0.00001, 0.0, 1.0);
	
	float u0 = 2.0*PI*noise00;
	float v0 = sqrt(-2.0 * log(noise01));
	float u1 = 2.0*PI*noise02;
	float v1 = sqrt(-2.0 * log(noise03));
	
	vec4 rnd = vec4(v0 * cos(u0), v0 * sin(u0), v1 * cos(u1), v1 * sin(u1));
	
	return rnd;
}

vec2 get_gauss(){
	ivec2 x = ivec2(gl_GlobalInvocationID.xy);
	int index = x.y * FFT_dimension  + x.x;
	return vec2(gauss_r.r[index], gauss_i.i[index]);
}


float P_k (vec2 k){
	
	float k_mag = length(k);
	float k_mag_sq = k_mag * k_mag;

	// prevent divide by 0
	if (k_mag < 0.001) 
		k_mag = 0.001;

	float L_  = (windspeed * windspeed)/G;  // largest possible wave for wind speed V
	float l   = L_ / 1000.0f;               // supress waevs smaller than this ??

	float k_dot_w = dot(normalize(k), normalize(wind_dir) );
	float e_term = exp(-1.0f /(k_mag_sq * L_ *L_));
	float p_k = amplitude  * e_term * pow(k_dot_w, k_w_power) / (k_mag_sq * k_mag_sq);

	// wave is moving against wind direction
	if(k_dot_w < 0.0f)
		p_k *= 0.07f;

	return p_k * exp(-k_mag_sq * l* l);       //What is this term for?
}

float h0_k (vec2 k){
	float h0k = sqrt(P_k(k)) / sqrt(2.0);
	return clamp(h0k, -4000.0, 4000.0) ;

}


void main(void)
{
	vec2 coord = vec2(gl_GlobalInvocationID.xy) - vec2(float(FFT_dimension/2)) ;
	ivec2 x = ivec2(gl_GlobalInvocationID.xy);
	vec2 k = vec2(2.0 * PI * coord.x/ocean_dimension, 2.0 * PI * coord.y/ocean_dimension);


	float h0k = h0_k(k);

	float h0minusk = h0_k(-k);
	//vec4 gauss_random = gaussRND();
	vec2 gauss = get_gauss();
	/*
	vec2 h0k_r_i      = h0k *gauss_random.xy;
	vec2 h0minusk_r_i = h0minusk* gauss_random.zw;
	*/
	vec2 h0k_r_i      = h0k *gauss.xy;
	vec2 h0minusk_r_i = h0minusk* gauss.xy;

	int index = x.y*FFT_dimension + x.x; 
	vec2 h0_precomputed = 10000*vec2(h0_r.r[index], h0_i.i[index]);

	//imageStore(tilde_h0k,      ivec2(gl_GlobalInvocationID.xy), vec4(h0k_r_i, 0, 1));
	imageStore(tilde_h0k,      ivec2(gl_GlobalInvocationID.xy), vec4(h0_precomputed, 0, 1));
	//imageStore(tilde_h0k,      ivec2(gl_GlobalInvocationID.xy), vec4(vec3(gauss.r), 1));
	imageStore(tilde_h0minusk, ivec2(gl_GlobalInvocationID.xy), vec4(h0minusk_r_i,0, 1));
	//imageStore(tilde_h0minusk, ivec2(gl_GlobalInvocationID.xy), vec4(vec3(gauss.g), 1));
}



