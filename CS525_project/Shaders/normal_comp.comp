#version 430 core

layout (local_size_x = 16, local_size_y = 16) in;
layout (binding = 0, rgba32f) readonly   uniform image2D displacement_map;
layout (binding = 1, rgba32f) writeonly  uniform image2D normal_map;
layout (binding = 2, rgba32f) writeonly  uniform image2D Jacobian_map;

uniform int FFT_dimension ;

vec3 central_normal();
float Jacobian();

void main (void){
	ivec2 loc = ivec2(gl_GlobalInvocationID.xy);

	vec3 n = central_normal();
	float J = Jacobian();

	imageStore(normal_map, loc, vec4(n, J));
	imageStore(Jacobian_map, loc, vec4(vec3(J), 1.0));
}

vec3 central_normal(){
	
	ivec2 loc       = ivec2(gl_GlobalInvocationID.xy);
	ivec2 right_loc = ivec2((loc.x + 1) % FFT_dimension, loc.y);
	ivec2 left_loc  = ivec2((loc.x - 1) % FFT_dimension, loc.y);
	ivec2 top_loc   = ivec2(loc.x                       , (loc.y - 1) % FFT_dimension);  // -1 or +1?
	ivec2 bot_loc   = ivec2(loc.x                       , (loc.y + 1) % FFT_dimension);

	float right_height = imageLoad(displacement_map, right_loc).y;
	float left_height  = imageLoad(displacement_map, left_loc).y;
	float top_height   = imageLoad(displacement_map, top_loc).y;
	float bot_height   = imageLoad(displacement_map, bot_loc).y;

	// central differnce normal equation from 
	// direction may be changed
	vec3 n = vec3( 2* (right_height - left_height), -4.0 , 2* (bot_height - top_height)     ) /4.0;

	return normalize(n);
}

float Jacobian(){

	ivec2 loc       = ivec2(gl_GlobalInvocationID.xy);
	ivec2 right_loc = ivec2((loc.x + 1) % FFT_dimension, loc.y);
	ivec2 left_loc  = ivec2((loc.x - 1) % FFT_dimension, loc.y);
	ivec2 top_loc   = ivec2(loc.x                       , (loc.y - 1) % FFT_dimension);  // -1 or +1?
	ivec2 bot_loc   = ivec2(loc.x                       , (loc.y + 1) % FFT_dimension);

	vec2 right_D = imageLoad(displacement_map, right_loc).xz;
	vec2 left_D  = imageLoad(displacement_map, left_loc).xz;
	vec2 top_D   = imageLoad(displacement_map, top_loc).xz;
	vec2 bot_D   = imageLoad(displacement_map, bot_loc).xz;

	// not sure about how much should the ax be
	vec2 DX = (right_D - left_D) / 2.0;
	vec2 DY = (bot_D - top_D)    / 2.0;

	return (1.0 + DX.x) * (1.0 + DY.y)  - DX.y * DY.x ;



}